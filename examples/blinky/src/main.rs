//! Blinky
//!
//! The classical LED flashing example for a PIC32MX1xx or PIC32MX2xx in a
//! 28 pin package. The clock in generated by the internal RC oscillator. So,
//! no other external parts except the 10 ÂµF capacitor at Vcap (pin 20) and a
//! LED connected via a resistor (e.g. 470 Ohms) to RB5 (pin 14) are needed.
//! RB0 (pin 4) is used to output some text via UART2.

#![no_main]
#![no_std]

use core::{fmt::Write, panic::PanicInfo};

use embedded_hal::{blocking::delay::DelayMs, digital::v2::*, serial::Read};
use mips_rt::{self, entry};
use pic32_config_sector::pic32mx2xx::*;
use pic32_hal::{
    clock::Osc,
    coretimer::Delay,
    gpio::GpioExt,
    pac,
    pps::{MapPin, NoPin, PpsExt},
    time::U32Ext,
    uart::Uart,
};

// PIC32 configuration registers for PIC32MX1xx and PIC32MX2xx
#[cfg(any(feature = "pic32mx1xxfxxxb", feature = "pic32mx2xxfxxxb"))]
#[link_section = ".configsfrs"]
#[used]
pub static CONFIGSFRS: ConfigSector = ConfigSector::default()
    .FVBUSONIO(FVBUSONIO::OFF)
    .FUSBIDIO(FUSBIDIO::OFF)
    .IOL1WAY(IOL1WAY::OFF)
    .PMDL1WAY(PMDL1WAY::OFF)
    .FPLLIDIV(FPLLIDIV::DIV_2)
    .FPLLMUL(FPLLMUL::MUL_20)
    .FPLLODIV(FPLLODIV::DIV_2)
    .FNOSC(FNOSC::FRCPLL)
    .FSOSCEN(FSOSCEN::OFF)
    .FPBDIV(FPBDIV::DIV_1)
    .FWDTEN(FWDTEN::OFF)
    .JTAGEN(JTAGEN::OFF)
    .ICESEL(ICESEL::ICS_PGx1)
    .build();

#[entry]
fn main() -> ! {
    let p = pac::Peripherals::take().unwrap();

    //pps.rpb0r.write(|w| unsafe { w.rpb0r().bits(0b0010) }); // U2TX on RPB0

    // setup clock control object
    let sysclock = 40_000_000_u32.hz();
    let clock = Osc::new(p.OSC, sysclock);
    let mut timer = Delay::new(sysclock);

    let parts = p.PORTB.split();
    let mut led = parts.rb5.into_push_pull_output();

    let vpins = p.PPS.split();

    let txd = parts
        .rb0
        .into_push_pull_output()
        .map_pin(vpins.outputs.u2tx);

    #[cfg(feature = "rx")]
    let rxd = parts.rb1.into_floating_input().map_pin(vpins.inputs.u2rx);
    #[cfg(not(feature = "rx"))]
    let rxd = NoPin::new().map_pin(vpins.inputs.u2rx);
    let uart = Uart::uart2(p.UART2, &clock, 115200, rxd, txd);
    timer.delay_ms(10u32);
    let (mut tx, mut rx) = uart.split();
    writeln!(tx, "Blinky example").unwrap();

    let mut on = true;
    loop {
        writeln!(tx, "LED status: {}", on).unwrap();
        if on {
            led.set_high().unwrap();
        } else {
            led.set_low().unwrap();
        }
        on = !on;
        if let Ok(byte) = rx.read() {
            writeln!(tx, "read char: '{}'", byte as char).unwrap();
        }
        timer.delay_ms(1000u32);
    }
}

#[panic_handler]
fn panic(_panic_info: &PanicInfo<'_>) -> ! {
    loop {}
}
