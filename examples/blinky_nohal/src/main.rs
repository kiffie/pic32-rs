//! Blinky without HAL
//!
//! The clock in generated by the internal RC oscillator. So, no other external
//! parts except the 10 ÂµF capacitor at Vcap and a LED connected via a resistor
//! (e.g. 470 Ohms) to RB5 are needed.
//!
#![no_main]
#![no_std]

use mips_mcu::core_timer::read_count;
use mips_rt::{self, entry};
use panic_halt as _;

#[cfg(feature = "pic32mx1xxfxxxb")]
use pic32_config_sector::pic32mx2xx::*;
#[cfg(feature = "pic32mx1xxfxxxb")]
use pic32mx2xx::pic32mx1xxfxxxb as pac;

#[cfg(feature = "pic32mx6xx")]
use pic32_config_sector::pic32mx567::*;
#[cfg(feature = "pic32mx6xx")]
use pic32mx567::pic32mx695fxxxl as pac;

// PIC32 configuration registers for PIC32MX1xx and PIC32MX2xx
#[cfg(any(feature = "pic32mx1xxfxxxb", feature = "pic32mx2xxfxxxb"))]
#[link_section = ".configsfrs"]
#[used]
pub static CONFIGSFRS: ConfigSector = ConfigSector::default()
    .FVBUSONIO(FVBUSONIO::OFF)
    .FUSBIDIO(FUSBIDIO::OFF)
    .IOL1WAY(IOL1WAY::OFF)
    .PMDL1WAY(PMDL1WAY::OFF)
    .FPLLIDIV(FPLLIDIV::DIV_2)
    .FPLLMUL(FPLLMUL::MUL_20)
    .FPLLODIV(FPLLODIV::DIV_2)
    .FNOSC(FNOSC::FRCPLL)
    .FSOSCEN(FSOSCEN::OFF)
    .FPBDIV(FPBDIV::DIV_1)
    .FWDTEN(FWDTEN::OFF)
    .JTAGEN(JTAGEN::OFF)
    .ICESEL(ICESEL::ICS_PGx1)
    .build();

// PIC32 configuration registers for PIC32MX6xx
#[cfg(feature = "pic32mx6xx")]
#[link_section = ".configsfrs"]
#[used]
pub static CONFIGSFRS: ConfigSector = ConfigSector::default()
    .FVBUSONIO(FVBUSONIO::OFF)
    .FUSBIDIO(FUSBIDIO::OFF)
    .FPLLIDIV(FPLLIDIV::DIV_2)
    .FPLLMUL(FPLLMUL::MUL_20)
    .FPLLODIV(FPLLODIV::DIV_2)
    .FNOSC(FNOSC::FRCPLL)
    .FSOSCEN(FSOSCEN::OFF)
    .FPBDIV(FPBDIV::DIV_1)
    .FWDTEN(FWDTEN::OFF)
    .ICESEL(ICESEL::ICS_PGx1)
    .build();

const SYSCLOCK: u32 = 40_000_000;

/// busy waiting loop using the MIPS core timer
fn delay_us(us: u32) {
    const TICKS_PER_US: u32 = SYSCLOCK / 1_000_000 / 2;
    let ticks = us * TICKS_PER_US;
    let start = read_count();
    while read_count().wrapping_sub(start) < ticks {}
}

#[entry]
fn main() -> ! {
    let p = pac::Peripherals::take().unwrap();

    // blink port RB5
    p.PORTB.trisclr.write(|w| w.trisb5().bit(true));

    loop {
        p.PORTB.latinv.write(|w| w.latb5().bit(true));
        delay_us(500_000);
    }
}
