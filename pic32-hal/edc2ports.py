#!/usr/bin/python3
#
# Copyright (c) 2021, 2023 Stephan <kiffie@mailbox.org>
#
# SPDX-License-Identifier: MIT OR Apache-2.0

"""
edc2pps.py
Create PIC32 port tables from .PIC XML files
"""

import datetime as dt
import argparse
import xml.etree.ElementTree as ET
import sys
import pycurl
from io import BytesIO
from pathlib import Path

BASE_URL = 'https://raw.githubusercontent.com/kiffie/pic32-pac/master'
# BASE_DIR = f'file:{Path.cwd()}/../..'
MCU_VARIANTS = {
    'pic32mx1xxfxxxb': BASE_URL + '/pic32mx2xx/pic32mx1xxfxxxb/PIC32MX170F256B.PIC',
    'pic32mx2xxfxxxb': BASE_URL + '/pic32mx2xx/pic32mx2xxfxxxb/PIC32MX270F256B.PIC',
    'pic32mx2x4fxxxb': BASE_URL + '/pic32mx2xx/pic32mx2x4fxxxb/PIC32MX274F256B.PIC',
    'pic32mx37x':      BASE_URL + '/pic32mx470/pic32mx37xfxxxl/PIC32MX370F512L.PIC',
    'pic32mx47x':      BASE_URL + '/pic32mx470/pic32mx47xfxxxl/PIC32MX470F512L.PIC',
}


def generate_tables(edc_root, mcu):
    out = ''
    # find pin list
    ns = {'edc': 'http://crownking/edc'}

    ports = {}
    for letter in "ABCDEFGHIJ":
        port_reg = edc_root.find(f".//edc:SFRDef[@{{http://crownking/edc}}cname='PORT{letter}']", ns)
        if not port_reg:
            continue
        ansel_reg = edc_root.find(f".//edc:SFRDef[@{{http://crownking/edc}}cname='ANSEL{letter}']", ns)
        port_access = port_reg.get('{http://crownking/edc}access')
        ansel_access = ansel_reg.get('{http://crownking/edc}access')
        port_desc = ""
        for (p, a) in zip(port_access, ansel_access):
            if p != 'n':
                code = "-"
            elif a == 'n':
                code = "a"
            else:
                code = "d"
            port_desc += code
        if len(port_desc) != 32:
            msg = f"unexpected length of bitmask of PORT{letter}"
            raise Exception(msg)
        ports[letter] = port_desc

    out += f"// Port definitions for {mcu}\n"
    out +=  "//\n"
    for (letter, desc) in ports.items():
        out += f"// PORT{letter}: {desc}\n"
    out += "//\n"

    for (letter, desc) in ports.items():
        llc = letter.lower()
        out += f'#[cfg(feature = "{mcu}")]\n'
        out += f"port!(PORT{letter}, port{llc}, [\n"
        for (i, c) in enumerate(reversed(desc)):
            match c:
                case 'a':
                    out += f"    R{letter}{i}: (r{llc}{i}, {i}, Input<Analog>, true),\n"
                case 'd':
                    out += f"    R{letter}{i}: (r{llc}{i}, {i}, Input<Floating>),\n"
        out += "]);\n\n"

    return out


def parseargs():
    parser = argparse.ArgumentParser()
    parser.add_argument("-o", "--output", help="path to output file")
    args = parser.parse_args()
    return args


def main():
    args = parseargs()

    if args.output:
        out = open(args.output, 'w')
    else:
        out = sys.stdout

    timestamp = dt.datetime.now(dt.timezone.utc)
    print(f'// generated by edc2ports on {timestamp}\n', file=out)
    for (mcu, edc_url) in iter(MCU_VARIANTS.items()):
        buf = BytesIO()
        curl = pycurl.Curl()
        curl.setopt(curl.URL, edc_url)
        curl.setopt(curl.WRITEDATA, buf)
        curl.perform()
        curl.close()
        edc_text = buf.getvalue().decode('utf-8')
        table = generate_tables(ET.fromstring(edc_text), mcu)
        print(table, file=out)


if __name__ == "__main__":
    main()
