#!/usr/bin/python3
#
# Copyright (c) 2021 Stephan <kiffie@mailbox.org>
#
# SPDX-License-Identifier: MIT OR Apache-2.0

"""
edc2pps.py
Create a PIC32 PPS tables from .PIC XML files
"""

import datetime as dt
import argparse
import xml.etree.ElementTree as ET
import sys
import requests

BASE_URL = 'https://raw.githubusercontent.com/kiffie/pic32-pac/master/pic32mx2xx'
MCU_VARIANTS = {
    'pic32mx1xxfxxxb': BASE_URL + '/pic32mx1xxfxxxb/PIC32MX170F256B.PIC',
    'pic32mx2xxfxxxb': BASE_URL + '/pic32mx2xxfxxxb/PIC32MX270F256B.PIC',
    'pic32mx2x4fxxxb': BASE_URL + '/pic32mx2x4fxxxb/PIC32MX274F256B.PIC'
}


def generate_tables(edc_root):
    out = ''
    # find pin list
    ns = {'edc': 'http://crownking/edc'}
    pin_list = edc_root.find('.//edc:PinList', ns)

    pps_pins = []
    for pin in pin_list.findall('./edc:Pin/edc:VirtualPin[@{http://crownking/edc}ppsgroup]', ns):
        name = 'R' + pin.get('{http://crownking/edc}name')[2:]
        pps_group = pin.get('{http://crownking/edc}ppsgroup')
        pps_value = pin.get('{http://crownking/edc}ppsval')
        if not name in map(lambda x: x[0], pps_pins):
            pps_pins.append((name, pps_group, pps_value))
    pps_pins.sort(key=lambda x: 0x100 * x[1] + x[2])

    inputs = []
    outputs = []
    for rpin in pin_list.findall('./edc:RemappablePin', ns):
        direction = rpin.get('{http://crownking/edc}direction')
        pin = rpin.find('edc:VirtualPin', ns)
        name = pin.get('{http://crownking/edc}name')
        if direction == "in":
            pps_group = pin.get('{http://crownking/edc}ppsgroup')
            inputs.append((name, pps_group))
        elif direction == "out":
            pps_group = pin.get('{http://crownking/edc}ppsgroup')
            pps_value = pin.get('{http://crownking/edc}ppsval')
            outputs.append((name, pps_group, pps_value))

    out += "pps_tables! {\n    { // virtual input declarations\n"
    for (i, grp) in sorted(inputs, key=lambda x: x[1]):
        out += f'        {i[0].upper() + i[1:].lower()}, {i.lower()};   // PPS group #{grp}\n'

    out += "    }{ // virtual output declarations\n"
    for output in sorted(set(map(lambda x: x[0], outputs))):
        out += f'        {output[0].upper() + output[1:].lower()}, {output.lower()};\n'

    out += '    }{ // virtual input mapping table\n'
    for (pin, pps_group) in sorted(inputs, key=lambda t: t[1]):
        type_name = pin[0].upper() + pin[1:].lower()
        reg = pin.lower() + 'r'
        out += f"        {type_name}, {reg} {{ // PPS group #{pps_group}\n"
        for (pname, pgrp, pval) in pps_pins:
            if pgrp == pps_group:
                port_letter = pname[1].lower()
                out += f"            gpio::port{port_letter}::{pname}<MODE>, {pval};\n"
        out += '        }\n'

    out += '    }{ // virtual output mapping table\n'
    for (pname, pgrp, pval) in pps_pins:
        type_name = pname[0].upper() + pname[1:].lower()
        port_letter = pname[1].lower()
        reg = 'rp' + pname[1:].lower() + 'r'
        out += f'        gpio::port{port_letter}::{pname}<MODE>, {reg} {{    // PPS group #{pgrp}\n'
        for (name, group, val) in sorted(outputs, key=lambda x: x[2]):
            type_name = name[0].upper() + name[1:].lower()
            if group == pgrp:
                out += f'            {type_name}, {val};\n'
        out += "        }\n"
    out += '    }\n}\n'
    return out


def parseargs():
    parser = argparse.ArgumentParser()
    parser.add_argument("-o", "--output", help="path to output file")
    args = parser.parse_args()
    return args


def main():
    args = parseargs()

    if args.output:
        out = open(args.output, 'w')
    else:
        out = sys.stdout

    timestamp = dt.datetime.now(dt.timezone.utc)
    print(f'//generated by edc2pps on {timestamp}\n', file=out)
    for (mcu, edc_url) in iter(MCU_VARIANTS.items()):
        edc_text = requests.get(edc_url).text
        table = generate_tables(ET.fromstring(edc_text))
        print(f'#[cfg(feature = "{mcu}")]\n{table}', file=out)


if __name__ == "__main__":
    main()
