#!/usr/bin/python3
#
# Copyright (c) 2021, 2023 Stephan <kiffie@mailbox.org>
#
# SPDX-License-Identifier: MIT OR Apache-2.0

"""
edc2pps.py
Create PIC32 PPS tables from .PIC XML files
"""

import datetime as dt
import argparse
import xml.etree.ElementTree as ET
import sys
import pycurl
from io import BytesIO
from pathlib import Path

BASE_URL = 'https://raw.githubusercontent.com/kiffie/pic32-pac/master'
# BASE_DIR = f'file:{Path.cwd()}/../..'
MCU_VARIANTS = {
    'pic32mx1xxfxxxb': BASE_URL + '/pic32mx2xx/pic32mx1xxfxxxb/PIC32MX170F256B.PIC',
    'pic32mx2xxfxxxb': BASE_URL + '/pic32mx2xx/pic32mx2xxfxxxb/PIC32MX270F256B.PIC',
    'pic32mx2x4fxxxb': BASE_URL + '/pic32mx2xx/pic32mx2x4fxxxb/PIC32MX274F256B.PIC',
    'pic32mx37x':      BASE_URL + '/pic32mx470/pic32mx37xfxxxl/PIC32MX370F512L.PIC',
    'pic32mx47x':      BASE_URL + '/pic32mx470/pic32mx47xfxxxl/PIC32MX470F512L.PIC'
}


def generate_tables(edc_root):
    out = ''
    ns = {'edc': 'http://crownking/edc'}

    pps_pins = []
    pin_list = edc_root.find('.//edc:PinList', ns)
    for pin in pin_list.findall('.//edc:Pin/edc:VirtualPin[@{http://crownking/edc}ppsgroup]', ns):
        name = 'R' + pin.get('{http://crownking/edc}name')[2:]
        reg_name = pin.get('{http://crownking/edc}name') + 'R'
        if not edc_root.find(f'.//edc:SFRDef[@{{http://crownking/edc}}name="{reg_name}"]', ns):
            reg_name = None
        pps_group = pin.get('{http://crownking/edc}ppsgroup')
        pps_value = pin.get('{http://crownking/edc}ppsval')
        if not name in map(lambda x: x[0], pps_pins):
            pps_pins.append((name, pps_group, pps_value, reg_name))
    pps_pins.sort(key=lambda x: 0x100 * x[1] + x[2])

    inputs = []
    outputs = []
    for rpin in pin_list.findall('./edc:RemappablePin', ns):
        direction = rpin.get('{http://crownking/edc}direction')
        pin = rpin.find('edc:VirtualPin', ns)
        name = pin.get('{http://crownking/edc}name')
        if direction == "in":
            pps_group = pin.get('{http://crownking/edc}ppsgroup')
            inputs.append((name, pps_group))
        elif direction == "out":
            pps_group = pin.get('{http://crownking/edc}ppsgroup')
            pps_value = pin.get('{http://crownking/edc}ppsval')
            outputs.append((name, pps_group, pps_value))

    out += "pps_tables! {\n    { // virtual input declarations\n"
    for (i, grp) in sorted(inputs, key=lambda x: x[1]):
        out += f'        {i[0].upper() + i[1:].lower()}, {i.lower()};   // PPS group #{grp}\n'

    out += "    }{ // virtual output declarations\n"
    for output in sorted(set(map(lambda x: x[0], outputs))):
        out += f'        {output[0].upper() + output[1:].lower()}, {output.lower()};\n'

    out += '    }{ // virtual input mapping table\n'
    for (pin, pps_group) in sorted(inputs, key=lambda t: t[1]):
        type_name = pin[0].upper() + pin[1:].lower()
        reg = pin.lower() + 'r'
        out += f"        {type_name}, {reg} {{ // PPS group #{pps_group}\n"
        for (pname, pgrp, pval, _) in pps_pins:
            if pgrp == pps_group:
                port_letter = pname[1].lower()
                out += f"            gpio::port{port_letter}::{pname}<MODE>, {pval};\n"
        out += '        }\n'

    out += '    }{ // virtual output mapping table\n'
    for (pname, pgrp, pval, reg_name) in pps_pins:
        type_name = pname[0].upper() + pname[1:].lower()
        port_letter = pname[1].lower()
        if reg_name:
            reg = reg_name.lower()
            out += f'        gpio::port{port_letter}::{pname}<MODE>, {reg} {{    // PPS group #{pgrp}\n'
            for (name, group, val) in sorted(outputs, key=lambda x: x[2]):
                type_name = name[0].upper() + name[1:].lower()
                if group == pgrp:
                    out += f'            {type_name}, {val};\n'
            out += "        }\n"
    out += '    }\n}\n'
    return out


def parseargs():
    parser = argparse.ArgumentParser()
    parser.add_argument("-o", "--output", help="path to output file")
    args = parser.parse_args()
    return args


def main():
    args = parseargs()

    if args.output:
        out = open(args.output, 'w')
    else:
        out = sys.stdout

    timestamp = dt.datetime.now(dt.timezone.utc)
    print(f'//generated by edc2pps on {timestamp}\n', file=out)
    for (mcu, edc_url) in iter(MCU_VARIANTS.items()):
        buf = BytesIO()
        curl = pycurl.Curl()
        curl.setopt(curl.URL, edc_url)
        curl.setopt(curl.WRITEDATA, buf)
        curl.perform()
        curl.close()
        edc_text = buf.getvalue().decode('utf-8')
        table = generate_tables(ET.fromstring(edc_text))
        print(f'#[cfg(feature = "{mcu}")]\n{table}', file=out)


if __name__ == "__main__":
    main()
